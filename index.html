<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arbol de la vida</title>
    <script src="calculo.js"></script>
    <style>
        .losInputs {
            position: absolute;
            left: 640px;
            top: 200px;
        }

        .esmerilado {
            box-shadow: 0 0 1rem 0 rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            background-color: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px;
        }

        .borde {
            background: hsla(0, 0%, 100%, 0.3);
            box-shadow: 0 8px 32px 0 rgb(31 38 135 / 37%);
            backdrop-filter: blur(1.5px);
            -webkit-backdrop-filter: blur(1.5px);
            border-radius: 10px;
            border: 4px solid hsla(0, 0%, 100%, 0.6);
        }

        .v-input {
            flex: 1 1 auto;
            font-size: 16px;
            letter-spacing: normal;

            color: rgba(0, 0, 0, 0.87);

            margin-top: 4px;
            line-height: 20px;
            padding: 8px 0;
            max-width: 100%;

            width: 100%;
        }

        input {
            outline: none;
            padding-left: 10px;
            background-color: transparent;
            border-style: none;
            border-radius: 0;

            writing-mode: horizontal-tb !important;

            text-rendering: auto;

            letter-spacing: normal;
            word-spacing: normal;

            text-transform: none;
            text-indent: 0px;
            text-shadow: none;
            display: inline-block;
            text-align: start;
            appearance: auto;
        }

        body {
            background-color: black;
        }

        .fondo {
            position: absolute;
            left: 0px;
            top: 0px;
            height: 1500px;
            width: 1500px;
            background-image: url(img/1500.jpg);
            background-size: 800px 800px;
            background-repeat: no-repeat;
            background-position: top left;

            background-position-x: -200px;
            background-position-y: -50px;
            opacity: 0.3;
        }

        #arbolCanvas {
            position: absolute;
            left: 20px;
            top: 19px;
        }

        .titulo {
            position: absolute;
            left: 500px;
            color: antiquewhite;
        }

        input:-webkit-autofill,
        input:-webkit-autofill:hover,
        input:-webkit-autofill:focus,
        input:-webkit-autofill:active {
            transition: background-color 9999s ease-in-out 0s;
        }
    </style>
</head>

<body>
    <div class="fondo"></div>
    <div class="titulo">
        <h1>Configuración Sefirótica</h1>
        <h3 style="color: red" id="muestraError">&nbsp;</h3>
    </div>
    <canvas id="arbolCanvas" width="1000" height="1000">
        Su navegador no admite el uso de Canvas</canvas>
    <div class="losInputs esmerilado">
        <div class="v-input borde">
            <input class="inputletra" type="text" value="Nombre completo" name="nombre" />
        </div>
        <div class="v-input borde">
            <input class="inputletra" type="text" value="Primer apellido" name="apellido" />
        </div>
        <div class="v-input borde">
            <input class="inputletra" type="text" value="Segundo apellido" name="apellido2" />
        </div>
        <hr />
        <label style="color: white">
            Fecha de nacimiento:
            <div class="v-input borde" style="text-align: center">
                <input class="inputletra" type="date" name="dia" />
            </div>
        </label>
    </div>
    <script>
        const color1 = "yellow";
        const color2 = "red";
        const color3 = "green";
        const puntosRadio = 20;

        const posiciones = [
            [70, 181],
            [134, 294],
            [134, 68],
            [265, 294],
            [265, 67],

            [330, 182],
            [396, 293],
            [396, 67],

            [461, 181],
            [592, 181],
        ];

        class Point {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.cuantos = 0;
            }
        }
        let linea = [
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];

        let punto = [];
        for (let p = 0; p < posiciones.length; p++) {
            punto[p + 1] = new Point(posiciones[p][1], posiciones[p][0]);
        }
        class Line {
            constructor(
                fromPoint = null,
                toPoint = null,
                zigZagged = false,
                dashed = false
            ) {
                this.from = fromPoint;
                this.to = toPoint;
                this.dashed = dashed;
                this.zigZagged = zigZagged;

                this.prepareZigZag();
            }

            setFrom(point) {
                this.from = point;
            }

            setTo(point) {
                this.to = toPoint;
            }

            getFrom() {
                return this.from;
            }

            getTo() {
                return this.to;
            }

            prepareZigZag() {
                // Get the radian angle of the line
                this.lineRadians = Math.atan2(
                    this.to.y - this.from.y,
                    this.to.x - this.from.x
                );

                // Get the length of the line
                const a = this.from.x - this.to.x;
                const b = this.from.y - this.to.y;
                this.lineLength = Math.sqrt(a * a + b * b);

                // 10 pixels between each zig zag "wave"
                this.zigzagSpacing = 5;

                // Length of one zig zag line - will in reality be doubled see below usage
                this.oneZigZagLength = 1;

                //Length of the last straight bit - so we do not zig zag all the line
                this.straightLengthWhenZigZag = 5;

                // The length of the zig zag lines
                this.zigZagLength = this.lineLength - this.straightLengthWhenZigZag;
            }

            draw(ctx, color = "#0ff", offsetx = 0, offsety = 0, lineWidth = 2.0) {
                if (this.dashed) {
                    ctx.setLineDash([12, 4]);
                } else {
                    ctx.setLineDash([]);
                }

                if (this.zigZagged) {
                    this.drawZigZagged(ctx, offsetx, offsety);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(this.from.x + offsetx, this.from.y + offsety);
                    ctx.lineTo(this.to.x + offsetx, this.to.y + offsety);
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;
                ctx.stroke();
            }

            drawZigZagged(ctx, offsetx = 0, offsety = 0) {
                // Save the current drawing state
                ctx.save();

                // Begin the new path
                ctx.beginPath();

                //Set the new 0, 0
                ctx.translate(this.from.x + offsetx, this.from.y + offsety);

                // Rotate the canvas so we can treat it like straight
                ctx.rotate(this.lineRadians);

                // Begin from 0, 0 (ie this.from.x, this.from.y)
                ctx.moveTo(0, 0);
                let zx = 0;
                // Create zig zag lines
                for (let n = 0; zx < this.zigZagLength; n++) {
                    // The new zig zag x position
                    zx = (n + 1) * this.zigzagSpacing;

                    // The new zig zag y position - each and other time up and down
                    const zy =
                        n % 2 == 0 ? -this.oneZigZagLength : this.oneZigZagLength;

                    // Draw the an actual line of the zig zag line
                    ctx.lineTo(zx, zy);
                }
                // Back to the center vertically
                ctx.lineTo(this.lineLength - this.straightLengthWhenZigZag / 2, 0);

                // Draw the last bit straight
                ctx.lineTo(this.lineLength, 0);

                // Restore the previous drawing state
                ctx.restore();
            }

            setDashed(enable) {
                this.dashed = enable;
            }

            setZigZagged(enable) {
                this.zigZagged = enable;
            }
        }

        const muestraErrorDiv = document.getElementById("muestraError");

        let canvas = document.getElementById("arbolCanvas");
        canvas.style.position = "absolute";
        let ctx = canvas.getContext("2d");

        // forma de estrella
        const estrellaCanvas = document.createElement("canvas");
        const estrella = estrellaCanvas.getContext("2d");
        var length = 4;
        estrellaCanvas.width = length * 3;
        estrellaCanvas.height = length * 3;
        estrella.fillStyle = "transparent";
        estrella.translate(length, length);
        estrella.beginPath();
        estrella.globalAlpha = 1;
        estrella.rotate((Math.PI / 180) * 90);
        estrella.scale(1, 1);
        estrella.strokeStyle = color3;
        estrella.fillStyle = color3;
        estrella.lineWidth = 1;
        for (var i = 5; i--;) {
            estrella.lineTo(0, length);
            estrella.translate(0, length);
            estrella.rotate((Math.PI * 2) / 10);
            estrella.lineTo(0, -length);
            estrella.translate(0, -length);
            estrella.rotate(-((Math.PI * 6) / 10));
        }
        estrella.lineTo(0, length);
        estrella.closePath();
        estrella.fill();
        estrella.stroke();
        const estrellapattern = ctx.createPattern(estrellaCanvas, "repeat");

        // //ejemplo linea torcida de estrellas
        // let xx = length * 3;
        // let region = new Path2D();
        // let to = { x: 181, y: 592 };
        // let from = { x: 67, y: 396 };

        // let lineRadians = Math.atan2(to.y - from.y, to.x - from.x);
        // const a = from.x - to.x;
        // const b = from.y - to.y;
        // let lineLength = Math.sqrt(a * a + b * b);
        // let zigZagLength = lineLength;
        // ctx.save();
        // ctx.beginPath();
        // ctx.translate(from.x, from.y);
        // ctx.rotate(lineRadians);
        // ctx.moveTo(0, 0);

        // region.moveTo(0, 0);
        // region.lineTo(0, 0 + xx);
        // region.lineTo(lineLength, 0 + xx);
        // region.lineTo(lineLength, 0);
        // region.lineTo(0, 0);
        // region.closePath();
        // ctx.fillStyle = estrellapattern;
        // ctx.fill(region);
        // ctx.restore();

        for (let y = 1; y <= 22; y++) {
            let zig = true;
            let disc = true;
            dibujaLinea(y, color1, zig, disc);
            dibujaLinea(y, color1, zig, disc);
            dibujaLinea(y, color1, zig, disc);
        }
        ponecirculos();


        var inputletra = document.getElementsByClassName("inputletra");
        for (let t = 0; t < inputletra.length; t++) {
            inputletra[t].onfocus = function () {
                this.value = "";
            };
            inputletra[t].onchange = function (e) {
                clear();
                if (this.name == "nombre") v_nombre = this.value;
                if (this.name == "apellido") v_apellido1 = this.value;
                if (this.name == "apellido2") v_apellido2 = this.value;
                if (this.name == "dia") {
                    var d = new Date(this.value + "T00:00:00");
                    v_año = d.getFullYear();
                    v_mes = d.getMonth() + 1;
                    v_dia = d.getDate();
                    // console.log(v_dia, v_mes, v_año);
                }

                // console.log(v_nombre && v_apellido1 && v_apellido2 && v_dia);
                muestraerror = "&nbsp;";
                if (v_nombre && v_apellido1 && v_apellido2 && v_dia) {
                    llenarFicha();
                    inputletra[0].value = v_nombre;
                    inputletra[1].value = v_apellido1;
                    inputletra[2].value = v_apellido2;

                    dibujarFicha();
                    //console.log(ficha);
                    //console.log(fichaConSectreto);
                }
                muestraErrorDiv.innerHTML = muestraerror;
                //setTimeout(resultado, 10);
            };
        }

        function dibujarFicha() {
            for (let t = 1; t <= 7; t++) {
                auxDibuja3(t, color1);
            }
            //ficha 8 en rojo
            let t = 8;
            auxDibuja3(t, color2);
            //ficha 9 en verde
            t = 9;
            auxDibuja3(t, color3);
            //ficha 10 y 12 en linea discontinua
            auxDibuja3(10, color1, false, true);
            auxDibuja3(12, color1, false, true);



        }

        function auxDibuja3(t, color, zig = false, discontinua = false) {
            dibujaLinea(ficha[t][0], color, false, discontinua);
            if (ficha[t][1] != null) {
                if (ficha[t][1] == fichaConSectreto[t])
                    dibujaLinea(ficha[t][1], color, true, discontinua);
                else dibujaLinea(ficha[t][1], color, false, discontinua);
            }
            if (ficha[t][2] != null) {
                if (ficha[t][2] == fichaConSectreto[t])
                    dibujaLinea(ficha[t][2], color, true, discontinua);
                else dibujaLinea(ficha[t][2], color, false, discontinua);
            }
        }

        function dibujaLinea(cual, color, zig = false, dash = false) {
            //console.log(cual, zig);
            //cuando hay mas de una linea, que se dibujen una al lado de la otra, si es impar sera a la izq de la pricipal
            let separacionOffset = 5;
            let offset =
                Math.pow(-1, linea[cual]) *
                separacionOffset *
                Math.ceil(linea[cual] / 2);
            //console.log("cuantos:", linea[cual], offset);
            linea[cual]++;
            switch (cual) {
                case 1:
                    punto[1].cuantos++;
                    punto[3].cuantos++;
                    new Line(punto[1], punto[3], zig, dash).draw(
                        ctx,
                        color,
                        offset * 0.5,
                        offset * 0.8
                    );
                    break;
                case 2:
                    punto[1].cuantos++;
                    punto[6].cuantos++;
                    new Line(punto[1], punto[6], zig, dash).draw(ctx, color, offset);
                    break;
                case 3:
                    punto[2].cuantos++;
                    punto[3].cuantos++;
                    new Line(punto[2], punto[3], zig, dash).draw(ctx, color, 0, offset);
                    break;
                case 4:
                    punto[2].cuantos++;
                    punto[6].cuantos++;
                    new Line(punto[2], punto[6], zig, dash).draw(
                        ctx,
                        color,
                        offset * 0.8,
                        offset * 0.5
                    );
                    break;
                case 5:
                    punto[2].cuantos++;
                    punto[4].cuantos++;
                    new Line(punto[2], punto[4], zig, dash).draw(ctx, color, offset);
                    break;
                case 6:
                    punto[3].cuantos++;
                    punto[6].cuantos++;
                    new Line(punto[3], punto[6], zig, dash).draw(
                        ctx,
                        color,
                        offset * -0.8,
                        offset * 0.5
                    );
                    break;
                case 7:
                    punto[5].cuantos++;
                    punto[3].cuantos++;
                    new Line(punto[5], punto[3], zig, dash).draw(ctx, color, offset, 0);
                    break;
                case 8:
                    punto[4].cuantos++;
                    punto[5].cuantos++;
                    new Line(punto[4], punto[5], zig, dash).draw(ctx, color, 0, offset);
                    break;
                case 9:
                    punto[4].cuantos++;
                    punto[6].cuantos++;
                    new Line(punto[4], punto[6], zig, dash).draw(
                        ctx,
                        color,
                        offset * 0.5,
                        offset * 0.8
                    );
                    break;
                case 10:
                    punto[4].cuantos++;
                    punto[7].cuantos++;
                    new Line(punto[4], punto[7], zig, dash).draw(ctx, color, offset);
                    break;
                case 11:
                    punto[5].cuantos++;
                    punto[6].cuantos++;
                    new Line(punto[6], punto[5], zig, dash).draw(
                        ctx,
                        color,
                        offset * -0.5,
                        offset * 0.8
                    );
                    break;
                case 12:
                    punto[5].cuantos++;
                    punto[8].cuantos++;
                    new Line(punto[8], punto[5], zig, dash).draw(ctx, color, offset);
                    break;
                case 13:
                    punto[7].cuantos++;
                    punto[6].cuantos++;
                    new Line(punto[6], punto[7], zig, dash).draw(
                        ctx,
                        color,
                        offset * -0.5,
                        offset * 0.8
                    );
                    break;
                case 14:
                    punto[9].cuantos++;
                    punto[6].cuantos++;
                    new Line(punto[9], punto[6], zig, dash).draw(ctx, color, offset);
                    break;
                case 15:
                    punto[8].cuantos++;
                    punto[6].cuantos++;
                    new Line(punto[6], punto[8], zig, dash).draw(
                        ctx,
                        color,
                        offset * 0.5,
                        offset * 0.8
                    );
                    break;
                case 16:
                    punto[7].cuantos++;
                    punto[8].cuantos++;
                    new Line(punto[7], punto[8], zig, dash).draw(ctx, color, 0, offset);
                    break;
                case 17:
                    punto[7].cuantos++;
                    punto[9].cuantos++;
                    new Line(punto[7], punto[9], zig, dash).draw(
                        ctx,
                        color,
                        offset * 0.5,
                        offset * 0.8
                    );
                    break;
                case 18:
                    punto[7].cuantos++;
                    punto[10].cuantos++;
                    new Line(punto[7], punto[10], zig, dash).draw(
                        ctx,
                        color,
                        offset * 0.8,
                        offset * 0.5
                    );
                    break;
                case 19:
                    punto[8].cuantos++;
                    punto[9].cuantos++;
                    new Line(punto[8], punto[9], zig, dash).draw(
                        ctx,
                        color,
                        offset * -0.5,
                        offset * 0.8
                    );
                    break;

                case 20:
                    punto[10].cuantos++;
                    punto[8].cuantos++;
                    new Line(punto[8], punto[10], zig, dash).draw(
                        ctx,
                        color,
                        offset * -0.8,
                        offset * 0.5
                    );
                    break;
                case 21:
                    punto[10].cuantos++;
                    punto[9].cuantos++;
                    new Line(punto[9], punto[10], zig, dash).draw(ctx, color, offset);
                    break;
                case 22:
                    punto[1].cuantos++;
                    punto[2].cuantos++;
                    new Line(punto[2], punto[1], zig, dash).draw(
                        ctx,
                        color,
                        offset * -0.5,
                        offset * 0.8
                    );
                    break;
                default:
                    return false;
            }
            ponecirculos();
            //console.log('linea', linea[19]);
        }

        function clear() {
            linea = [
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            ];
            for (let p = 0; p < posiciones.length; p++) {
                punto[p + 1].cuantos = 0;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ponecirculos();
        }

        function ponecirculos() {
            var innerRadius = 5;

            let gradient;
            for (let p = 0; p < posiciones.length; p++) {
                ctx.beginPath();
                ctx.arc(
                    posiciones[p][1],
                    posiciones[p][0],
                    puntosRadio,
                    0,
                    2 * Math.PI
                );
                gradient = ctx.createRadialGradient(
                    posiciones[p][1],
                    posiciones[p][0],
                    innerRadius,
                    posiciones[p][1],
                    posiciones[p][0],
                    puntosRadio
                );
                gradient.addColorStop(0, "yellow");
                gradient.addColorStop(1, "blue");
                ctx.fillStyle = gradient;
                ctx.fill();
                //ctx.strokeStyle = "blue";
                //ctx.stroke();
            }
        }

    </script>
</body>

</html>